This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
practice-app/
  public/
    vite.svg
  src/
    app/
      providers/
        with-chakra.tsx
    entities/
      Curve/
        model/
          use-curve-points.ts
        ui/
          Curve.tsx
        index.ts
      Primitive/
        ui/
          Primitive.tsx
        index.ts
    features/
      AnimatePrimitive/
        model/
          use-primitive-animation.ts
        ui/
          AnimationControls.tsx
        index.ts
      UpdateGraphParams/
        ui/
          GraphParamsForm.tsx
        index.ts
    pages/
      GraphPage/
        ui/
          GraphPage.tsx
        index.ts
    shared/
      lib/
        hooks/
          use-element-size.ts
      types/
        index.ts
    widgets/
      GraphViewer/
        ui/
          GraphViewer.tsx
        index.ts
    index.css
    main.tsx
    vite-env.d.ts
  .gitignore
  eslint.config.js
  index.html
  package.json
  README.md
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  tsconfig.tsbuildinfo
  vite.config.d.ts
  vite.config.js
  vite.config.ts
.gitignore
LICENSE
README.md

================================================================
Files
================================================================

================
File: practice-app/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: practice-app/src/app/providers/with-chakra.tsx
================
import { ChakraProvider } from '@chakra-ui/react';
import React from 'react';

export const withChakra = (component: () => React.ReactNode) => () => (
  <ChakraProvider>
    {component()}
  </ChakraProvider>
);

================
File: practice-app/src/entities/Curve/model/use-curve-points.ts
================
import { useMemo } from 'react';
import { Point, CurveParams } from '@/shared/types';

// Эта функция теперь вычисляет только "чистые" математические координаты
const calculatePascalLimaçonPoint = (t: number, a: number, k: number): Point => {
  const r = a * (k + Math.cos(t));
  const x = r * Math.cos(t);
  const y = r * Math.sin(t);
  return { x, y };
};

// Хук теперь не зависит от размеров сцены и не выполняет масштабирование
export const useCurvePoints = (params: CurveParams): Point[] => {
  return useMemo(() => {
    const points: Point[] = [];
    const { a, k, steps, turnsCount } = params;

    for (let i = 0; i <= steps; i++) {
      const t = (i / steps) * turnsCount * 2 * Math.PI;
      const mathPoint = calculatePascalLimaçonPoint(t, a, k);
      points.push(mathPoint);
    }
    return points;
  }, [params]);
};

================
File: practice-app/src/entities/Curve/ui/Curve.tsx
================
import { Line } from 'react-konva';
import { Point } from '@/shared/types';

interface CurveProps {
    points: Point[];
}

export const Curve = ({ points }: CurveProps) => {
    // Преобразуем массив точек в плоский массив [x1, y1, x2, y2, ...]
    const flatPoints = points.flatMap(p => [p.x, p.y]);

    // ИСПОЛЬЗУЕМ ОБЫЧНЫЙ КОМПОНЕНТ Line ИЗ react-konva БЕЗ АНИМАЦИИ.
    // ЭТО КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ, УСТРАНЯЮЩЕЕ КОНФЛИКТ.
    return (
        <Line
            points={flatPoints}
            stroke="black"
            strokeWidth={2}
            tension={0.5} // Сглаживание линии
            lineCap="round"
            lineJoin="round"
            shadowColor="black"
            shadowBlur={5}
            shadowOpacity={0.3}
            perfectDrawEnabled={false} // Оптимизация для динамических линий
            listening={false} // Линия не должна перехватывать события мыши
        />
    );
};

================
File: practice-app/src/entities/Curve/index.ts
================
export { Curve } from './ui/Curve';
export { useCurvePoints } from './model/use-curve-points';
export type { CurveParams } from './model/use-curve-points';

================
File: practice-app/src/entities/Primitive/ui/Primitive.tsx
================
import { forwardRef } from 'react';
import Konva from 'konva';
import { Rect } from 'react-konva';
import { Point } from '@/shared/types';

interface PrimitiveProps {
    position: Point; // математические координаты внутри Stage
    size: number;    // итогу­вый размер в пикселях экрана(!)
}

export const Primitive = forwardRef<Konva.Rect, PrimitiveProps>(
    ({ position, size }, ref) => (
        <Rect
            ref={ref}
            x={position.x - size / 2}
            y={position.y - size / 2}
            width={size}
            height={size}
            fill="blue"
            listening={false}
            perfectDrawEnabled={false}
        />
    )
);
Primitive.displayName = 'Primitive';

================
File: practice-app/src/entities/Primitive/index.ts
================
export { Primitive } from './ui/Primitive';

================
File: practice-app/src/features/AnimatePrimitive/model/use-primitive-animation.ts
================
import { useState, useRef, useCallback, useEffect } from 'react';
import Konva from 'konva';
import { Point } from '@/shared/types';

export const usePrimitiveAnimation = (
    points: Point[],
    onPositionUpdate: (pos: Point) => void
) => {
  const [isAnimating, setIsAnimating] = useState(false);
  const animationRef = useRef<Konva.Animation | null>(null);
  const layerRef = useRef<Konva.Layer | null>(null);

  const stopAnimation = useCallback(() => {
    if (animationRef.current?.isRunning()) {
      animationRef.current.stop();
    }
    setIsAnimating(false);
  }, []); // Пустой массив зависимостей, т.к. функция не зависит от пропсов/стейта

  const startAnimation = useCallback(() => {
    if (isAnimating || points.length < 2 || !layerRef.current) {
      return;
    }

    if (!animationRef.current) {
      animationRef.current = new Konva.Animation((frame) => {
        if (!frame || points.length === 0) return;
        const duration = 8000;
        const progress = (frame.time % duration) / duration;
        const index = Math.floor(progress * points.length);
        onPositionUpdate(points[index % points.length]);
      }, layerRef.current);
    }

    animationRef.current.start();
    setIsAnimating(true);
  }, [isAnimating, points, onPositionUpdate]);

  const setLayer = useCallback((layer: Konva.Layer | null) => {
    layerRef.current = layer;
  }, []);

  useEffect(() => {
    // Эта функция очистки вызывается при размонтировании компонента.
    // Она безопасно останавливает анимацию, предотвращая утечки памяти.
    return () => {
      animationRef.current?.stop();
    };
  }, []); // Пустой массив зависимостей = выполнится один раз

  return { isAnimating, startAnimation, stopAnimation, setLayer };
};

================
File: practice-app/src/features/AnimatePrimitive/ui/AnimationControls.tsx
================
import { Button, HStack } from '@chakra-ui/react';

interface AnimationControlsProps {
  isAnimating: boolean;
  onStart: () => void;
  onStop: () => void;
  disabled: boolean;
}

export const AnimationControls = ({ isAnimating, onStart, onStop, disabled }: AnimationControlsProps) => {
  return (
    <HStack>
      <Button onClick={onStart} isDisabled={isAnimating || disabled} colorScheme="green">Старт</Button>
      <Button onClick={onStop} isDisabled={!isAnimating || disabled} colorScheme="red">Стоп</Button>
    </HStack>
  );
};

================
File: practice-app/src/features/AnimatePrimitive/index.ts
================
export { AnimationControls } from './ui/AnimationControls';
export { usePrimitiveAnimation } from './model/use-primitive-animation';

================
File: practice-app/src/features/UpdateGraphParams/ui/GraphParamsForm.tsx
================
import React, { useState, useEffect } from 'react';
import { CurveParams } from '@/shared/types';
import {
    Box,
    Button,
    FormControl,
    FormLabel,
    Grid,
    Heading,
    Input,
    Slider,
    SliderFilledTrack,
    SliderThumb,
    SliderTrack,
    Text,
    VStack,
    Divider,
    Flex
} from '@chakra-ui/react';

interface GraphParamsFormProps {
    initialParams: CurveParams;
    onParamsChange: (params: CurveParams) => void;
    // НОВОЕ: Пропсы для управления масштабом
    manualZoom: number;
    onZoomChange: (zoom: number) => void;
}

export const GraphParamsForm = ({ initialParams, onParamsChange, manualZoom, onZoomChange }: GraphParamsFormProps) => {
    const [params, setParams] = useState<CurveParams>(initialParams);

    useEffect(() => {
        const timeoutId = setTimeout(() => {
            onParamsChange(params);
        }, 100);

        return () => clearTimeout(timeoutId);
    }, [params, onParamsChange]);

    useEffect(() => {
        setParams(initialParams);
    }, [initialParams]);

    const updateParam = <K extends keyof CurveParams>(
        key: K,
        value: CurveParams[K]
    ) => {
        setParams(prev => ({
            ...prev,
            [key]: value
        }));
    };

    const resetToDefaults = () => {
        // ИСПРАВЛЕНИЕ: Значения по умолчанию теперь согласованы с INITIAL_PARAMS
        const defaultParams: CurveParams = {
            a: 1,
            k: 2,
            steps: 1000,
            turnsCount: 10
        };
        setParams(defaultParams);
        onZoomChange(1); // Также сбрасываем ручной зум
    };


    return (
        <VStack spacing={6} align="stretch">
            {/* НОВОЕ: Слайдер для ручного масштабирования */}
            <FormControl>
                <FormLabel fontSize="sm" fontWeight="medium">
                    Масштаб (зум): {manualZoom.toFixed(2)}x
                </FormLabel>
                <Slider
                    min={0.5}
                    max={5}
                    step={0.1}
                    value={manualZoom}
                    onChange={onZoomChange}
                >
                    <SliderTrack>
                        <SliderFilledTrack />
                    </SliderTrack>
                    <SliderThumb />
                </Slider>
                <Flex justify="space-between">
                    <Text fontSize="xs" color="gray.500">0.5x</Text>
                    <Text fontSize="xs" color="gray.500">5.0x</Text>
                </Flex>
            </FormControl>

            <Divider />

            {/* Параметр a */}
            <FormControl>
                <FormLabel fontSize="sm" fontWeight="medium">
                    Параметр 'a' (радиус): {params.a}
                </FormLabel>
                <Slider min={20} max={200} step={5} value={params.a} onChange={(val) => updateParam('a', val)} >
                    <SliderTrack><SliderFilledTrack /></SliderTrack>
                    <SliderThumb />
                </Slider>
            </FormControl>

            {/* Параметр k */}
            <FormControl>
                <FormLabel fontSize="sm" fontWeight="medium">
                    Параметр 'k' (форма): {params.k}
                </FormLabel>
                <Slider min={0.1} max={5} step={0.1} value={params.k} onChange={(val) => updateParam('k', val)} >
                    <SliderTrack><SliderFilledTrack /></SliderTrack>
                    <SliderThumb />
                </Slider>
            </FormControl>

            {/* Количество шагов */}
            <FormControl>
                <FormLabel fontSize="sm" fontWeight="medium">
                    Количество точек: {params.steps}
                </FormLabel>
                <Slider min={100} max={2000} step={100} value={params.steps} onChange={(val) => updateParam('steps', val)} >
                    <SliderTrack><SliderFilledTrack /></SliderTrack>
                    <SliderThumb />
                </Slider>
            </FormControl>

            {/* Количество оборотов */}
            <FormControl>
                <FormLabel fontSize="sm" fontWeight="medium">
                    Количество оборотов: {params.turnsCount}
                </FormLabel>
                <Slider min={1} max={20} step={1} value={params.turnsCount} onChange={(val) => updateParam('turnsCount', val)} >
                    <SliderTrack><SliderFilledTrack /></SliderTrack>
                    <SliderThumb />
                </Slider>
            </FormControl>

            {/* Точный ввод значений и остальная часть формы... */}
            {/* ... (остальной код формы без изменений) ... */}
            <Box pt={4}>
                <Divider />
                <Button onClick={resetToDefaults} w="full" mt={4} variant="outline">
                    Сбросить к значениям по умолчанию
                </Button>
            </Box>

            <Box pt={4}>
                <Divider />
                <Heading as="h4" size="sm" fontWeight="medium" my={2}>
                    О кривой Подера
                </Heading>
                <VStack align="start" fontSize="xs" color="gray.600" spacing={1}>
                    <Text>• r = a(k + cos(t))</Text>
                    <Text>• При k = 1: кардиоида</Text>
                    <Text>• При k &lt; 1: кривая с петлей</Text>
                    <Text>• При k &gt; 1: выпуклая кривая</Text>
                </VStack>
            </Box>
        </VStack>
    );
};

================
File: practice-app/src/features/UpdateGraphParams/index.ts
================
export { GraphParamsForm } from './ui/GraphParamsForm';

================
File: practice-app/src/pages/GraphPage/ui/GraphPage.tsx
================
import { useState, useRef, useEffect, useMemo } from 'react'; // Добавляем useCallback
import Konva from 'konva';
import {
  Box, Button, Container, Divider, Grid, GridItem,
  Heading, Text, VStack
} from '@chakra-ui/react';

import { CurveParams, Point, Bounds } from '@/shared/types';
import { useCurvePoints } from '@/entities/Curve';
import { usePrimitiveAnimation } from '@/features/AnimatePrimitive';
import { GraphParamsForm } from '@/features/UpdateGraphParams';
import { GraphViewer } from '@/widgets/GraphViewer';
import { Primitive } from '@/entities/Primitive';
import { useElementSize } from '@/shared/lib/hooks/use-element-size';

const INITIAL_PARAMS: CurveParams = { a: 1, k: 2, steps: 1000, turnsCount: 10 };
const MAX_AUTO_SCALE = 100;
const BASE_PRIMITIVE_SIZE = 15;

const getBounds = (pts: Point[]): Bounds | null => {
  if (!pts.length) return null;
  let minX = pts[0].x, maxX = pts[0].x,
      minY = pts[0].y, maxY = pts[0].y;
  for (const p of pts) {
    if (p.x < minX) minX = p.x;
    if (p.x > maxX) maxX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
};

export const GraphPage = () => {
  const [params, setParams] = useState(INITIAL_PARAMS);
  const [manualZoom, setManualZoom] = useState(1);
  const [primitivePos, setPrimitivePos] = useState<Point | null>(null);

  const layerRef = useRef<Konva.Layer>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // ИСПРАВЛЕНИЕ: Мемоизируем `curvePoints` здесь, чтобы он был стабильным
  // между рендерами, если `params` не изменились.
  const curvePoints = useMemo(() => useCurvePoints(params), [params]);

  const canvasSize = useElementSize(containerRef);

  const { autoScale, bounds } = useMemo(() => {
    if (!canvasSize.width || !canvasSize.height || curvePoints.length === 0) {
      return { autoScale: 1, bounds: null };
    }
    const b = getBounds(curvePoints);
    if (!b || b.width === 0 || b.height === 0) {
      return { autoScale: 1, bounds: b };
    }
    const sX = canvasSize.width / b.width;
    const sY = canvasSize.height / b.height;
    return {
      autoScale: Math.min(MAX_AUTO_SCALE, Math.min(sX, sY) * 0.9),
      bounds: b
    };
  }, [curvePoints, canvasSize]);

  const finalScale = autoScale * manualZoom;
  const primitiveScreenSz = Math.max(3, BASE_PRIMITIVE_SIZE / finalScale);

  const { isAnimating, startAnimation, stopAnimation, setLayer }
      = usePrimitiveAnimation(curvePoints, setPrimitivePos);

  // ИСПРАВЛЕНИЕ: Этот эффект теперь зависит только от `params`.
  // Это гарантирует, что он запускается только при изменении параметров кривой,
  // а не при каждом рендере. `stopAnimation` также включен в зависимости.
  useEffect(() => {
    stopAnimation();
    if (curvePoints.length > 0) {
      setPrimitivePos(curvePoints[0]);
    }
  }, [params, stopAnimation]); // `curvePoints` удален из зависимостей

  useEffect(() => {
    if (layerRef.current) {
      setLayer(layerRef.current);
    }
  }, [setLayer]);

  return (
      <Box minH="100vh" bg="gray.50">
        <Container maxW="container.xl" py={8}>
          <Heading mb={6}>Улитка Паскаля – вариант 23</Heading>
          <Grid templateColumns={{ base:'1fr', lg:'380px 1fr' }} gap={8}>
            <GridItem>
              <Box bg="white" p={6} shadow="lg" borderRadius="lg">
                <GraphParamsForm
                    initialParams={params}
                    onParamsChange={setParams}
                    manualZoom={manualZoom}
                    onZoomChange={setManualZoom}
                />
                <Divider my={6} />
                <VStack spacing={3}>
                  <Button onClick={startAnimation} isDisabled={isAnimating} colorScheme="blue" w="full">
                    {isAnimating ? 'Анимация…' : 'Старт'}
                  </Button>
                  <Button onClick={stopAnimation} isDisabled={!isAnimating} colorScheme="red" w="full">
                    Стоп
                  </Button>
                </VStack>
              </Box>
            </GridItem>
            <GridItem minW={0}>
              <Box bg="white" p={6} shadow="lg" borderRadius="lg">
                <Box
                    ref={containerRef}
                    h="650px" w="100%"
                    border="1px solid" borderColor="gray.200"
                    borderRadius="md" overflow="hidden"
                >
                  {canvasSize.width > 0 && (
                      <GraphViewer
                          ref={layerRef}
                          width={canvasSize.width}
                          height={canvasSize.height}
                          scale={finalScale}
                          curvePoints={curvePoints}
                          offsetX={bounds ? bounds.minX + bounds.width  / 2 : 0}
                          offsetY={bounds ? bounds.minY + bounds.height / 2 : 0}
                          draggable
                      >
                        {primitivePos && <Primitive position={primitivePos} size={primitiveScreenSz} />}
                      </GraphViewer>
                  )}
                </Box>
                <Text mt={4} fontSize="sm" color="gray.600">
                  r = a·(k + cos t), a={params.a}, k={params.k}
                </Text>
              </Box>
            </GridItem>
          </Grid>
        </Container>
      </Box>
  );
};

================
File: practice-app/src/pages/GraphPage/index.ts
================
export { GraphPage } from './ui/GraphPage';

================
File: practice-app/src/shared/lib/hooks/use-element-size.ts
================
import { useState, useLayoutEffect, RefObject } from 'react';

export function useElementSize<T extends HTMLElement>(elementRef: RefObject<T>) {
  const [size, setSize] = useState({ width: 0, height: 0 });

  useLayoutEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const observer = new ResizeObserver(() => {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight,
      });
    });

    observer.observe(element);
    // Устанавливаем начальный размер
    setSize({ width: element.offsetWidth, height: element.offsetHeight });

    return () => {
      observer.disconnect();
    };
  }, [elementRef]);

  return size;
}

================
File: practice-app/src/shared/types/index.ts
================
export type Point = {
  x: number;
  y: number;
};

export interface CurveParams {
  a: number;
  k: number;  // Исправлено с l на k
  steps: number;
  turnsCount: number;
  scale?: number; // Опциональный параметр
}
export type Bounds = {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
  width: number;
  height: number;
};

================
File: practice-app/src/widgets/GraphViewer/ui/GraphViewer.tsx
================
import React, { forwardRef } from 'react';
import { Stage, Layer } from 'react-konva';
import { Curve } from '@/entities/Curve';
import { Point } from '@/shared/types';
import Konva from 'konva';

interface GraphViewerProps {
    width: number;
    height: number;
    scale: number;
    curvePoints: Point[];
    children?: React.ReactNode;
    // НОВОЕ: Пропсы для центрирования и перетаскивания
    offsetX?: number;
    offsetY?: number;
    draggable?: boolean;
}

export const GraphViewer = forwardRef<Konva.Layer, GraphViewerProps>(
    ({ width, height, scale, curvePoints, children, offsetX, offsetY, draggable }, ref) => {
        return (
            <Stage
                width={width}
                height={height}
                scaleX={scale}
                scaleY={scale}
                // НОВОЕ: Центрирование вида и включение перетаскивания
                x={width / 2}
                y={height / 2}
                offsetX={offsetX}
                offsetY={offsetY}
                draggable={draggable}
            >
                <Layer ref={ref}>
                    <Curve points={curvePoints} />
                    {children}
                </Layer>
            </Stage>
        );
    }
);

GraphViewer.displayName = 'GraphViewer';

================
File: practice-app/src/widgets/GraphViewer/index.ts
================
export { GraphViewer } from './ui/GraphViewer';

================
File: practice-app/src/index.css
================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  color-scheme: light; /* Force light mode for consistency */
  color: #213547;
  background-color: #ffffff;
}

body {
  margin: 0;
}

================
File: practice-app/src/main.tsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { GraphPage } from './pages/GraphPage';
import { withChakra } from './app/providers/with-chakra';
import './index.css';

const App = withChakra(GraphPage);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

================
File: practice-app/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: practice-app/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: practice-app/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: practice-app/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: practice-app/package.json
================
{
  "name": "practice-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@chakra-ui/react": "^2.8.2",
    "@emotion/react": "^11.11.4",
    "@emotion/styled": "^11.11.5",
    "@react-spring/konva": "^9.7.5",
    "@react-spring/web": "^9.7.5",
    "framer-motion": "^10.18.0",
    "konva": "^9.3.20",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.5.0",
    "react-konva": "^18.2.10"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/node": "^24.0.3",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.7",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

================
File: practice-app/README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

================
File: practice-app/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: practice-app/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

================
File: practice-app/tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true, // ДОБАВЛЕНО: Включает режим "составного проекта" для правильной сборки.
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    // "noEmit": true, // УДАЛЕНО: Составные проекты должны иметь возможность генерировать файлы.

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: practice-app/tsconfig.tsbuildinfo
================
{"root":["./src/main.tsx","./src/vite-env.d.ts","./src/app/providers/with-chakra.tsx","./src/entities/curve/index.ts","./src/entities/curve/model/use-curve-points.ts","./src/entities/curve/ui/curve.tsx","./src/entities/primitive/index.ts","./src/entities/primitive/ui/primitive.tsx","./src/features/animateprimitive/index.ts","./src/features/animateprimitive/model/use-primitive-animation.ts","./src/features/animateprimitive/ui/animationcontrols.tsx","./src/features/updategraphparams/index.ts","./src/features/updategraphparams/ui/graphparamsform.tsx","./src/pages/graphpage/index.ts","./src/pages/graphpage/ui/graphpage.tsx","./src/shared/lib/hooks/use-element-size.ts","./src/shared/types/index.ts","./src/widgets/graphviewer/index.ts","./src/widgets/graphviewer/ui/graphviewer.tsx"],"errors":true,"version":"5.8.3"}

================
File: practice-app/vite.config.d.ts
================
declare const _default: import("vite").UserConfig;
export default _default;

================
File: practice-app/vite.config.js
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
// https://vite.dev/config/
export default defineConfig({
    plugins: [react()],
    server: {
        hmr: {
            overlay: false // Отключает overlay с ошибками в браузере
        }
    },
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src'),
        },
    },
});

================
File: practice-app/vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    hmr: {
      overlay: false // Отключает overlay с ошибками в браузере
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})

================
File: .gitignore
================
### react template
.DS_*
*.log
logs
**/*.backup.*
**/*.back.*

node_modules
bower_components

*.sublime*

psd
thumb
sketch

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Волошин Владимир Константинович

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# educational_practice_at_the_university



================================================================
End of Codebase
================================================================
